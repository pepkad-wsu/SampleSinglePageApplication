using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using System.Collections;
using System.Reflection;
using SampleSinglePageApplication;

namespace SampleSinglePageApplication.Transcriber // Note: actual namespace depends on the project name.
{
    internal partial class Program
    {
        private SampleSinglePageApplication.EFModels.EFModels.EFDataModel _data = null;

        private static async Task Main(string[] args)
        {
            // So the first time it runs it looks at the DataObjects class and trancribes it into different files..
            // This might generate more classes in the DataObject files, which will then need to be transcribed
            // so it needs to be ran a second time to catch the generated data object files.
            // The auto generated data object files will never generate more data object files, so it doesn't need to be ran a third time. 
            for (int i = 0; i < 2; i++) {
                Console.WriteLine("i: " + i);
                var _data = new SampleSinglePageApplication.EFModels.EFModels.EFDataModel();
                //C:\Repos\Git\SampleSinglePageApplication\SampleSinglePageApplication.Transcriber
                // TODO:  parse the path from this method
                var dir = System.IO.Directory.GetCurrentDirectory();
                var split = dir.Split("\\").Reverse().Skip(4).Reverse();
                var str = string.Join("\\", split) + "\\";
                var path = str; //@"C:\Repos\SSPA_Transcriber\SampleSinglePageApplication\";
                var transcribedClasses = TranscriberUtilities.TranscribeClasses(_data);
                WriteDataAccessAutos(transcribedClasses, path, @"SampleSinglePageApplication.DataAccess\", @"SampleSinglePageApplication.Web\Views\Partials\"); //DataAccess.Auto.cs
                WriteDataControllerAutos(transcribedClasses, path, @"SampleSinglePageApplication.Web\Controllers\"); //DataAccess.Auto.cs
                WriteDataObjectAutos(transcribedClasses, path, @"SampleSinglePageApplication.DataObjects\"); //DataAccess.Auto.cs
                WriteKnockoutAutos(transcribedClasses, path, @"SampleSinglePageApplication.Web\wwwroot\js\", "sampleSinglePageApplicationEnumAutos", "sampleSinglePageApplicationDataBindingAutos"); //Models.SampleSinglePageApplication.Auto.ts
                WriteOutDtoAutos(transcribedClasses, path, @"SampleSinglePageApplication.Web\wwwroot\js\");
                WriteViewsModelsAutos(transcribedClasses, path, @"SampleSinglePageApplication.Web\Views\Shared\"); //DataAccess.Auto.cs
            }
        }

        private static void WriteDataAccessAutos(List<TranscribedClass> transcribedClass, string path, string dataAccessFolder, string partialViewFolder)
        {

            var languageAutoOutput = new List<string>();
            languageAutoOutput.Add("/// ");
            languageAutoOutput.Add("/// Sample Single Page Applications language autos");
            languageAutoOutput.Add("/// ");
            languageAutoOutput.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
            languageAutoOutput.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
            languageAutoOutput.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
            languageAutoOutput.Add("///");
            languageAutoOutput.Add("namespace SampleSinglePageApplication;");
            languageAutoOutput.Add("public partial interface IDataAccess ");
            languageAutoOutput.Add("{");
            languageAutoOutput.Add("\tDictionary<string, string> GetLanguageAutos();");
            languageAutoOutput.Add("}");
            languageAutoOutput.Add("");
            languageAutoOutput.Add("public partial class DataAccess");
            languageAutoOutput.Add("{");
            languageAutoOutput.Add("\tpublic Dictionary<string, string> GetLanguageAutos() ");
            languageAutoOutput.Add("\t{");
            languageAutoOutput.Add("\t\tDictionary<string, string> output = new Dictionary<string, string>();");

            /// Write out the data access autos
            foreach (TranscribedClass item in transcribedClass.Where(o => o.Info.IsEfModel || o.Info.IsEnum).ToList()) {
                var output = new List<string>();

                if (item.Info.IsEnum) {
                    output.Add("/// ");
                    output.Add("/// " + item.Info.PascalCaseClassName);
                    output.Add("/// ");
                    output.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                    output.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                    output.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                    output.Add("///");
                    output.AddRange(item.CSharpDataAccessEnums);
                } else if (item.Info.IsEfModel) {
                    output.Add("/// ");
                    output.Add("/// " + item.Info.PascalCaseClassName);
                    output.Add("/// ");
                    output.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                    output.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                    output.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                    output.Add("///");
                    // ok now the language autos
                    output.AddRange(item.CSharpDataAccessLanguageDefaults);
                    output.AddRange(item.CSharpDataAccess);

                    //https://stackoverflow.com/questions/294138/merging-dictionaries-in-c-sharp
                    languageAutoOutput.Add("\t\tGet" + item.Info.PascalCaseClassName + "LanguageAuto().ToList().ForEach(x => output[x.Key] = x.Value);");
                }
                File.WriteAllLines(Path.Join("" + path, dataAccessFolder + $"autos\\DataAccess.{item.Info.PascalCaseClassName}Autos.cs"), output);

                // now do the language auto file
                
            }
            languageAutoOutput.Add("");
            languageAutoOutput.Add("\t\treturn output;");
            languageAutoOutput.Add("\t}");
            languageAutoOutput.Add("}");

            File.WriteAllLines(Path.Join("" + path, dataAccessFolder + $"autos\\DataAccess.LanguageAutos.cs"), languageAutoOutput);
        }

        private static void WriteDataControllerAutos(List<TranscribedClass> transcribedClass, string path, string dataControllerFolder)
        {
            /// Write out the data access autos
            foreach (TranscribedClass item in transcribedClass.Where(o => o.Info.IsEfModel).ToList()) {
                var output = new List<string>();

                if (!item.Info.IsEnum && item.Info.IsEfModel) {
                    output.Add("/// ");
                    output.Add("/// " + item.Info.PascalCaseClassName);
                    output.Add("/// ");
                    output.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                    output.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                    output.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                    output.Add("///");
                    output.AddRange(item.CSharpDataControllers);
                }
                File.WriteAllLines(Path.Join("" + path, dataControllerFolder + $"Autos\\DataController.{item.Info.PascalCaseClassName}Autos.cs"), output);
            }
        }

        private static void WriteDataObjectAutos(List<TranscribedClass> transcribedClass, string path, string dataObjectsFolder)
        {
            /// Write out the data access autos
            foreach (TranscribedClass item in transcribedClass.Where(o => o.Info.IsEfModel).ToList()) {
                var output = new List<string>();
                output.Add("using Newtonsoft.Json;");
                output.Add("namespace SampleSinglePageApplication;");
                output.Add("public partial class DataObjects");
                output.Add("{");
                output.Add("");
                if (!item.Info.IsEnum && item.Info.IsEfModel) {
                    output.Add("");
                    output.Add("\t/// ");
                    output.Add("\t/// " + item.Info.PascalCaseClassName);
                    output.Add("\t/// ");
                    output.Add("\t/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                    output.Add("\t/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                    output.Add("\t///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                    output.Add("\t///");
                    output.AddRange(item.CSharpDataObjects);
                }
                output.Add("}");
                File.WriteAllLines(Path.Join("" + path, dataObjectsFolder + $"Autos\\DataObjects.{item.Info.PascalCaseClassName}Autos.cs"), output);
            }
        }

        /// <summary>
        /// Actually write out the knockout models contents out to a file.    dto's and knockout contents are slightly different
        /// </summary>
        /// <param name="path"></param>
        /// <param name="jsFolder"></param>
        private static void WriteKnockoutAutos(List<TranscribedClass> transcribedClass, string path, string jsFolder, string enumNamespace, string dataBindingNamespace)
        {
            /// do we have enums? If so we need to make some helper methods for converting them to and from strings
                // first do the typescript versions

            var knockoutOutput = new List<string>();


            knockoutOutput.Add("interface Window {");
            foreach(var item in transcribedClass) {
                if (!string.IsNullOrWhiteSpace(item.WindowInterfaceTypeScriptResults)) {
                    knockoutOutput.Add(item.WindowInterfaceTypeScriptResults);
                }
            }
            knockoutOutput.Add("}");

            knockoutOutput.Add("namespace " + enumNamespace + " {");
            foreach (TranscribedClass item in transcribedClass.ToList()) {
                if (item.Info.IsEnum) {
                    knockoutOutput.Add("\t/// ");
                    knockoutOutput.Add("\t/// " + item.Info.PascalCaseClassName);
                    knockoutOutput.Add("\t/// ");
                    knockoutOutput.Add("\t/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                    knockoutOutput.Add("\t/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                    knockoutOutput.Add("\t///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                    knockoutOutput.Add("\t///");
                    knockoutOutput.AddRange(item.KnockoutTypeScriptResults);
                }
            }
            knockoutOutput.Add("}");

            foreach (TranscribedClass item in transcribedClass.Where(o => !o.Info.IsEnum).ToList()) {
                knockoutOutput.Add("/// ");
                knockoutOutput.Add("/// " + (item.KnockoutTypeScriptResults.Count() > 0 ? item.KnockoutTypeScriptResults[0].Split("{")[1] : ""));
                knockoutOutput.Add("/// ");
                knockoutOutput.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                knockoutOutput.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                knockoutOutput.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                knockoutOutput.Add("///");
                knockoutOutput.AddRange(item.KnockoutTypeScriptResults);
            }
            // write the file out
            File.WriteAllLines(Path.Join("" + path, jsFolder + "Models.SampleSinglePageApplication.Auto.ts"), knockoutOutput);

            foreach (TranscribedClass item in transcribedClass.Where(o => !o.Info.IsEnum && o.Info.IsEfModel).ToList()) {
                var viewModelOutput = new List<string>();
                viewModelOutput.Add("/// ");
                viewModelOutput.Add("/// " + item.Info.PascalCaseClassName);
                viewModelOutput.Add("/// ");
                viewModelOutput.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                viewModelOutput.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                viewModelOutput.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                viewModelOutput.Add("///");
                viewModelOutput.AddRange(item.ViewModels);
                File.WriteAllLines(Path.Join("" + path, jsFolder + $"viewModels\\autos\\{item.Info.CamelCaseClassName}Autos.ts"), viewModelOutput);
            }

            var knockoutViewModelBindings = new List<string>();

            knockoutViewModelBindings.Add("namespace " + dataBindingNamespace + " {");
            knockoutViewModelBindings.Add("    export function ApplyKnockoutViewModelBindingsAuto() {");

            foreach (var item in transcribedClass.Where(o => o.Info.IsEfModel).ToList()) {
                knockoutViewModelBindings.Add("\twindow." + item.Info.CamelCaseClassName + "sModelAuto = new " + item.Info.PascalCaseClassName + "sModelAuto();");
                knockoutViewModelBindings.Add("\tko.applyBindings(window." + item.Info.CamelCaseClassName + "sModelAuto, document.getElementById('view-" + item.Info.CamelCaseClassName.ToLower() + "s-auto'));");
                knockoutViewModelBindings.Add("");
            }
            knockoutViewModelBindings.Add("\t}");
            knockoutViewModelBindings.Add("}");

            File.WriteAllLines(Path.Join("" + path, jsFolder + "viewModels\\autos\\ViewModelBindingAutos.ts"), knockoutViewModelBindings);
        }

        /// <summary>
        /// Actually write out the dto contents out to a file.  dto's and knockout contents are slightly different
        /// </summary>
        /// <param name="path"></param>
        /// <param name="filename"></param>
        private static void WriteOutDtoAutos(List<TranscribedClass> transcribedClass, string path, string filename, List<Type>? types = null)
        {
            var dtosOutput = new List<string>();
            // add the declare module server at the top of the file
            dtosOutput.Add("declare module server {");
            var dtosOutputCount = 0;
            foreach (var item in transcribedClass) {
                dtosOutput.Add("");
                dtosOutput.Add("\t/// ");
                dtosOutput.Add("\t/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                dtosOutput.Add("\t/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                dtosOutput.Add("\t///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                dtosOutput.Add("\t///");
                foreach (var row in item.DtoTypeScriptResults) {
                    dtosOutput.Add("\t" + row);
                }

                dtosOutputCount++;
            }
            // close the opening { from the declare module server statement
            dtosOutput.Add("}");

            // write the file out
            File.WriteAllLines(Path.Join("" + path, filename + "DTOs.SampleSinglePageApplication.Auto.ts"), dtosOutput);
        }

        private static void WriteViewsModelsAutos(List<TranscribedClass> transcribedClass, string path, string partialViewFolder)
        {
            /// Write out the data access autos
            foreach (var item in transcribedClass.Where(o => o.Info.IsEfModel)) {
                var partialViewsOutput = new List<string>();
                ///partialViewsOutput.Add("@*/// ");
                ///partialViewsOutput.Add("/// " + item.Info.CSharpClassName);
                ///partialViewsOutput.Add("/// ");
                ///partialViewsOutput.Add("/// WARNING: AUTO GENERATED FILE - DO NOT MODIFY BY HAND");
                ///partialViewsOutput.Add("/// GENERATED BY: SampleSinglePageApplication.Transcriber console application.");
                ///partialViewsOutput.Add("///   To regenerate the file, first update the path varibale in the program.cs then run the console app.");
                ///partialViewsOutput.Add("///*@");
                partialViewsOutput.AddRange(item.PartialViews);
                File.WriteAllLines(Path.Join("" + path, partialViewFolder + $"autos\\_partial{item.Info.PascalCaseClassName}Autos.cshtml"), partialViewsOutput);
            }
            var partialIncludesAutos = new List<string>();

            foreach (var item in transcribedClass.Where(o => o.Info.IsEfModel)) {
                partialIncludesAutos.Add("@await Html.PartialAsync(\"autos/_partial" + item.Info.PascalCaseClassName + "Autos\")");
            }
            File.WriteAllLines(Path.Join("" + path, partialViewFolder + $"autos\\_partialIncludesAutos.cshtml"), partialIncludesAutos);

            var partialAdminNavBarAuto = new List<string>();
            foreach (var item in transcribedClass.Where(o => o.Info.IsEfModel)) {
                partialAdminNavBarAuto.Add("<li><a class=\"dropdown-item\" href=\"#\" data-bind=\"click:function(){ Nav('" + item.Info.PascalCaseClassName + "sAuto'); }, css: { active: CurrentView() == '" + item.Info.CamelCaseClassName + "sAuto' || CurrentView() == '" + item.Info.CamelCaseClassName + "Auto' || CurrentView() == 'new" + item.Info.CamelCaseClassName + "Auto'}\"><i data-bind=\"html:IconAndText('" + item.Info.PascalCaseClassName+ "s')\"></i></a></li>");
            }

            File.WriteAllLines(Path.Join("" + path, partialViewFolder + $"autos\\_partialAdminNavBarAuto.cshtml"), partialAdminNavBarAuto);

            // ok now make the admin auto include
        }
    }
}
